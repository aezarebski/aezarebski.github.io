<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-01-29 Wed 13:42 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>pypfilt-notes</title>
<meta name="author" content="Alexander E. Zarebski" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">pypfilt-notes</h1>
<p>
<a href="../index.html">Home</a>
</p>


<div id="org997fafe" class="figure">
<p><img src="../images/pypfilt-logo.png" alt="pypfilt-logo.png" width="250px" />
</p>
</div>

<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0d6c2ca">Pypfilt</a></li>
<li><a href="#org55b9069">Terminology</a></li>
<li><a href="#org6d2eb03">Examples: flipping coins</a>
<ul>
<li><a href="#orgaf85c5d">Data</a></li>
<li><a href="#org0298263">Scenario file</a></li>
<li><a href="#org3a14f25">Main script</a></li>
</ul>
</li>
<li><a href="#org441e0b8">Examples: birth-death process</a>
<ul>
<li><a href="#noisy-count-obs-model">Observation model</a></li>
<li><a href="#tau-leap-bd">Tau-leaping birth-death</a></li>
<li><a href="#ode-bd">ODE birth-death</a></li>
<li><a href="#ode-bd-again">ODE birth-death (again)</a></li>
<li><a href="#ctmc-bd">CTMC birth-death</a></li>
</ul>
</li>
<li><a href="#org8d7ca8d">Colophon</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0d6c2ca" class="outline-2">
<h2 id="org0d6c2ca">Pypfilt</h2>
<div class="outline-text-2" id="text-org0d6c2ca">
<ul class="org-ul">
<li><a href="https://pypfilt.readthedocs.io/en/0.8.0/">Pypfilt documentation 0.8.0</a></li>
<li><a href="https://bitbucket.org/robmoss/particle-filter-for-python/src/master/">Pypfilt on Bitbucket</a></li>
<li><a href="https://bitbucket.org/robmoss/epidemic-forecasting-for-python/src/master/">Epifx on Bitbucket</a></li>
</ul>


<div id="orgbdebb8c" class="figure">
<p><img src="./pypfilt/pypfilt-class-diagram.png" alt="pypfilt-class-diagram.png" width="950px" />
</p>
<p><span class="figure-number">Figure 1: </span>A class diagram showing the main classes that a user will interact with when using <code>pypfilt</code> along with the classes that are used in the examples on this page.</p>
</div>
</div>
</div>

<div id="outline-container-org55b9069" class="outline-2">
<h2 id="org55b9069">Terminology</h2>
<div class="outline-text-2" id="text-org55b9069">
<dl class="org-dl">
<dt><i>observation model</i></dt><dd>the distribution of a random variable (e.g.,
the measured population size) given the state (e.g., the true
population.)</dd>
<dt><i>process model</i></dt><dd>a stochastic process for the state, e.g., how the
population size changes through time.</dd>
<dt><i>scenario</i></dt><dd>a description of a simulation or an inference problem,
e.g., estimating the birth rate and the future population sizes.
Think: "an imagined sequence of events."</dd>
</dl>
</div>
</div>

<div id="outline-container-org6d2eb03" class="outline-2">
<h2 id="org6d2eb03">Examples: flipping coins</h2>
<div class="outline-text-2" id="text-org6d2eb03">
<p>
Consider the problem of estimating the probability a coin comes up
heads. Let \(\theta\) be the probability of heads. Our data are the
random variables \(H_{i}|\theta\sim\text{Bernoulli}(\theta)\) for
\(i=1,\ldots,5\). We will use the prior distribution
\(\theta\sim\text{Beta}(1, 1)\). For \(\sum_{i=1}^{5} H_{i} = 3\), the
posterior distribution is \(\theta|\mathcal{D}\sim\text{Beta}(4,3)\).
</p>

<p>
A comparison of the credible intervals for the analytic solution and
the result from using a particle filter (with only 100 particles) is
shown in the following figure.
</p>


<div id="orgc26c752" class="figure">
<p><img src="./pypfilt/coin-example.png" alt="coin-example.png" width="400px" />
</p>
<p><span class="figure-number">Figure 2: </span>Credible intervals for the probability of heads based on 3 heads in 5 flips.</p>
</div>
</div>

<div id="outline-container-orgaf85c5d" class="outline-3">
<h3 id="orgaf85c5d">Data</h3>
<div class="outline-text-3" id="text-orgaf85c5d">
<p>
Here is our data, saved in a file <code>coin-results.ssv</code>.
</p>

<pre class="example">
time value
1.0 1
2.0 0
3.0 1
4.0 0
5.0 1
</pre>
</div>
</div>

<div id="outline-container-org0298263" class="outline-3">
<h3 id="org0298263">Scenario file</h3>
<div class="outline-text-3" id="text-org0298263">
<p>
Here is a scenario file describing the inference problem.
</p>

<div class="org-src-container">
<pre class="src src-toml">[components]
model = "coin_example.ConstantParameter"
time = "pypfilt.Scalar"
sampler = "pypfilt.sampler.LatinHypercube"
summary = "pypfilt.summary.HDF5"

[time]
start = 0.0
until = 5.0
steps_per_unit = 1
summaries_per_unit = 1

[prior]
theta = { name = "uniform", args.loc = 0.0, args.scale = 1.0 }

[observations.theta]
model = "coin_example.BernoulliObservation"
file = "coin-results.ssv"

[filter]
particles = 100
prng_seed = 1
history_window = 0
resample.threshold = 0.25

[scenario.inference]
summary.tables.model_cints.component = "pypfilt.summary.ModelCIs"
summary.tables.model_cints.credible_intervals = [ 10, 20, 30, 40, 50, 60, 70, 80, 90 ]
</pre>
</div>
</div>
</div>

<div id="outline-container-org3a14f25" class="outline-3">
<h3 id="org3a14f25">Main script</h3>
<div class="outline-text-3" id="text-org3a14f25">
<div class="org-src-container">
<pre class="src src-python"># coin-example.py
#
# program: Coin flipping example
#
# programmer: Alexander E. Zarebski
# date: 2023-08-28
#
# description: A simple example of parameter estimation with the fit
# method in a case where we know the solution analytically
#
#
import numpy as np
import scipy.stats
import pypfilt
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import matplotlib as matplotlib
matplotlib.use('QtAgg')
import pandas as pd
import plotnine as p9
from plotnine import *
#
#
#  ************************************************
#  *                                              *
#  * Define the simulation and observation models *
#  *                                              *
#  ************************************************
#
#
class ConstantParameter(pypfilt.model.Model):
    def field_types(self, ctx):
        return [('theta', np.dtype(float))]

    def init(self, ctx, vec):
        prior = ctx.data['prior']
        vec['theta'] = prior['theta']

    def update(self, ctx, time_step, is_forecast, prev, curr):
        curr[:] = prev[:]


class BernoulliObservation(pypfilt.obs.Univariate):
    def distribution(self, ctx, snapshot):
        p = snapshot.state_vec[self.unit]
        return scipy.stats.bernoulli(p)
#
#
#  ***************************************************
#  *                                                 *
#  * Use the particle filter to sample the posterior *
#  *                                                 *
#  ***************************************************
#
#
inst = list(pypfilt.load_instances("coin.toml"))[0]
ctx = inst.build_context()
fit = pypfilt.fit(ctx, filename=None)
pst_df = pd.DataFrame(fit.estimation.tables['model_cints'])
pst_df = pst_df[pst_df['time'] == 5.0][['prob','ymin', 'ymax']]
#
#
#  ************************************************
#  *                                              *
#  * Plot the approximate and analytic posteriors *
#  *                                              *
#  ************************************************
#
#
coin_flips = pd.read_table("coin-results.ssv", sep = ' ')['value']
num_flips = coin_flips.size
num_heads = coin_flips.sum()
post_dist = scipy.stats.beta(a = num_heads + 1, b = num_flips - num_heads + 1)

plt_df = pst_df.copy()
plt_df['ymax_beta'] = post_dist.ppf(1 - 0.01 * 0.5 * (100 - plt_df['prob']))
plt_df['ymin_beta'] = post_dist.ppf(0.01 * 0.5 * (100 - plt_df['prob']))
plt_df = pd.melt(plt_df,
                 id_vars = ['prob'],
                 value_vars = ['ymin', 'ymax', 'ymin_beta', 'ymax_beta'])
plt_df['type'] = plt_df['variable'].apply(lambda v: 'Analytic' if ('beta' in v) else 'Particle filter')

cri_p9 = (ggplot()
          + geom_point(
              data = plt_df,
              mapping = aes(x = "prob",
                            y = "value",
                            color = "type"))
          + geom_line(
              data = plt_df,
              mapping = aes(x = "prob",
                            y = "value",
                            color = "type",
                            group = "variable"))
          + labs(title = "Coin flipping example",
                 y = "Credible interval for theta",
                 x = "Coverage probability (%)",
                 color = "Method")
          + theme_bw()

    )
cri_p9.save("coin-example.png",
        height = 4.1, width = 5.8)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org441e0b8" class="outline-2">
<h2 id="org441e0b8">Examples: birth-death process</h2>
<div class="outline-text-2" id="text-org441e0b8">
<p>
We can model the birth-death process in a number of ways:
</p>

<ul class="org-ul">
<li>with <a href="#tau-leap-bd">Tau-leaping</a>;</li>
<li>with <a href="#ode-bd">ODEs</a>; and <a href="#ode-bd-again">again</a> using the <code>fit</code> method;</li>
<li>and as a <a href="#ctmc-bd">CTMC</a>.</li>
</ul>

<p>
For each example, we will consider observations with Poisson noise
about the true state. The observation model is described with the
<a href="#noisy-count-obs-model">NoisyCount</a> observation distribution.
</p>
</div>

<div id="outline-container-noisy-count-obs-model" class="outline-3">
<h3 id="noisy-count-obs-model">Observation model</h3>
<div class="outline-text-3" id="text-noisy-count-obs-model">
<p>
As stated above, we will assume Poisson noise about the true value of
the state. This is implemented as the <code>NoisyCount</code> class. This class
will be used with each of the different process representations.
</p>

<div class="org-src-container">
<pre class="src src-python"># NoisyCount.py

&lt;&lt;imports&gt;&gt;

class NoisyCount(pypfilt.obs.Univariate):
    def distribution(self, ctx, snapshot):
        expected_value = snapshot.state_vec['x']
        return scipy.stats.poisson(mu=expected_value)
</pre>
</div>
</div>
</div>

<div id="outline-container-tau-leap-bd" class="outline-3">
<h3 id="tau-leap-bd">Tau-leaping birth-death</h3>
<div class="outline-text-3" id="text-tau-leap-bd">
<p>
Consider an approximation of the birth-death process using
\(\tau\)-leaping. The following example demonstrates how to simulate
from this process and run a forecast to estimate both the future state
and the birth rate (assuming a known death rate and initial
condition).
</p>
</div>

<div id="outline-container-org0e06664" class="outline-4">
<h4 id="org0e06664">Process model</h4>
<div class="outline-text-4" id="text-org0e06664">
<p>
We start by defining a model for this process using \(\tau\)-leaping.
</p>

<div class="org-src-container">
<pre class="src src-python"># TauLeapBirthDeathProcess.py

&lt;&lt;imports&gt;&gt;

class TauLeapBirthDeathProcess(pypfilt.model.Model):
    def field_types(self, ctx):
        return [('birth', np.dtype(float)),
                ('death', np.dtype(float)),
                ('x', np.dtype(int))]

    def update(self, ctx, time_step, is_fs, prev, curr):
        """Destructively update the current state."""
        rnd = ctx.component['random']['model']
        net_rate = (prev['birth'] - prev['death']) * time_step.dt * prev['x']
        curr['birth'] = prev['birth']
        curr['death'] = prev['death']
        curr['x'] = prev['x'] + rnd.poisson(lam=net_rate, size=curr['x'].shape)
</pre>
</div>

<p>
Note that in the <code>update</code> method we need to destructively update
<code>curr</code> to contain the new value. I.e., <code>curr</code> should be considered a
reference to the state, this avoids needing to make a copy of this
data.
</p>
</div>
</div>

<div id="outline-container-org805b537" class="outline-4">
<h4 id="org805b537">Scenario file</h4>
<div class="outline-text-4" id="text-org805b537">
<p>
The simulation and estimation computations are specified with a TOML
file <code>approx-bd-example.toml</code>.
</p>

<div class="org-src-container">
<pre class="src src-toml">[metadata]
name = "Tau leap birth-death example"
filename = "tau-leap-bd-example.toml"
author = "Alexander E. Zarebski"
date = "2023-07-25"

[components]
model = "TauLeapBirthDeathProcess.TauLeapBirthDeathProcess"
time = "pypfilt.Scalar"
sampler = "pypfilt.sampler.LatinHypercube"
summary = "pypfilt.summary.HDF5"

[time]
start = 0.0
until = 5.0
steps_per_unit = 10
summaries_per_unit = 2

[prior]
death = { name = "constant", args.value = 1.0 }
x = { name = "constant", args.value = 1 }

[observations.x]
model = "NoisyCount.NoisyCount"
file = "tau-leap-bd-example-x.ssv"

[filter]
particles = 10000
prng_seed = 42
history_window = -1
resample.threshold = 0.25
regularisation.enabled = true

[scenario.simulate]
prior.birth = { name = "constant", args.value = 2.0 }

[scenario.forecast]
summary.tables.model_cints.component = "pypfilt.summary.ModelCIs"
summary.tables.model_cints.credible_intervals = [ 0, 25, 50, 75, 95 ]
summary.tables.forecasts.component = "pypfilt.summary.PredictiveCIs"
summary.tables.forecasts.credible_intervals = [10, 20, 40, 80]
prior.birth = { name = "uniform", args.loc = 1.0, args.scale = 3.0 }
backcast_time = 0.0
forecast_time = 4.0

[output]
credible_intervals = "demo-tau-leap-bd-cris.ssv"
estimate_plot = "tau-leap-bd-posterior-estimates.png"
forecast_plot = "tau-leap-bd-posterior-forecasts.png"
</pre>
</div>

<p>
Note, apart from <code>scenario.simulate</code> and <code>scenario.forecast</code>, all the
configuration is shared between the two tasks. The process model and
observation model needs to be described with <b>both</b> the module and the
class within it.
</p>

<p>
The specification of the prior distributions appears to take the
location as the right end of the uniform distribution and the scale is
the width of the uniform distribution. This may not be wildly
intuitive, but bear in mind that there are sophisticated options for
specifying a prior distribution available.
</p>
</div>
</div>

<div id="outline-container-org92b370f" class="outline-4">
<h4 id="org92b370f">Main script</h4>
<div class="outline-text-4" id="text-org92b370f">
<p>
Here is the main script that runs the simulation and estimation.
</p>

<div class="org-src-container">
<pre class="src src-python"># tau-leap-bd-example.py

&lt;&lt;imports&gt;&gt;
&lt;&lt;plotting-imports&gt;&gt;

scenario_file = 'tau-leap-bd-example.toml'
instances = list(pypfilt.load_instances(scenario_file))
sim_instance = instances[0]
my_time_scale = sim_instance.time_scale()
my_obs_tables = pypfilt.simulate_from_model(sim_instance)

for (obs_unit, obs_table) in my_obs_tables.items():
    out_file = f'tau-leap-bd-example-{obs_unit}.ssv'
    pypfilt.io.write_table(out_file, obs_table, my_time_scale)
</pre>
</div>

<p>
To run the forecasts on the simulated data we have the following
</p>

<div class="org-src-container">
<pre class="src src-python">fst_instance = instances[1]
backcast_time = fst_instance.settings['backcast_time']
forecast_time = fst_instance.settings['forecast_time']
context = fst_instance.build_context()
results = pypfilt.forecast(context, [forecast_time], filename=None)
</pre>
</div>

<p>
We can generate a plot of the forecast values, and the estimate of the
historical states of the process.
</p>

<div class="org-src-container">
<pre class="src src-python">fit = results.estimation.tables['forecasts']
forecast = results.forecasts[forecast_time].tables['forecasts']
credible_intervals = np.concatenate((
    fit[fit['time'] &gt;= backcast_time],
    forecast))

cri_df = pd.DataFrame(credible_intervals)
cri_df = cri_df.assign(prob = cri_df['prob'])
obs_df = pd.read_csv('tau-leap-bd-example-x.ssv', sep=' ')
obs_df = obs_df[obs_df['time'] &gt;= backcast_time]
obs_df = obs_df.assign(observed = obs_df['time'] &lt;= forecast_time)

fs_p9 = (ggplot()
         + geom_ribbon(data = cri_df,
                       mapping = aes(x = "time",
                                     ymin = "ymin",
                                     ymax = "ymax",
                                     group = "prob"),
                       alpha = 0.2)
         + scale_x_continuous(name = "Time")
         + scale_y_sqrt(name = "Population size")
         + geom_point(data = obs_df,
                      mapping = aes(x = "time",
                                    y = "value",
                                    shape = "observed"),
                      size = 3,
                      colour = "red")
         + scale_shape_manual(values = {True: 'o', False: 'x'})
         + geom_vline(xintercept = forecast_time,
                      linetype = "dashed")
         + labs(title = "Population size forecast")
         + theme_bw()
         + theme(legend_position = "none"))

fs_p9.save(instances[1].settings['output']['forecast_plot'],
           height = 4.1, width = 5.8)
</pre>
</div>

<p>
Here are the <a href="#org1d19da5">results</a> of the particle filter.
</p>


<div id="org1d19da5" class="figure">
<p><img src="./pypfilt/tau-leap-bd-posterior-forecasts.png" alt="tau-leap-bd-posterior-forecasts.png" width="400px" />
</p>
<p><span class="figure-number">Figure 3: </span>Forecast of birth-death process</p>
</div>

<p>
We can also generate a plot of how the posterior distribution
converges on the true value of the parameter as the amount of data
available increases.
</p>

<div class="org-src-container">
<pre class="src src-python">param_cris_df = pd.DataFrame(results.estimation.tables['model_cints'])
param_cris_df = param_cris_df[param_cris_df['name'] == 'birth']
param_cris_df['prob'] = pd.Categorical(
    param_cris_df['prob'],
    categories=param_cris_df['prob'].unique(),
    ordered=True
)
pt_est_mask = param_cris_df['prob'] == 0

br_p9 = (ggplot()
         + geom_ribbon(data = param_cris_df,
                       mapping = aes(x = "time",
                                     ymin = "ymin",
                                     ymax = "ymax",
                                     group = "prob"),
                       alpha = 0.2,
                       size = 1)
         + geom_line(data = param_cris_df[pt_est_mask],
                     mapping = aes(x = "time",
                                   y = "ymin"))
         + geom_hline(yintercept = 2.0, linetype = "dashed", colour = "red")
         + scale_x_continuous(name = "Amount of data used")
         + scale_y_continuous(name = "Birth rate")
         + labs(title = "Birth rate credible intervals")
         + theme_bw())

br_p9.save(instances[1].settings['output']['estimate_plot'],
           height = 4.1, width = 5.8)
</pre>
</div>

<p>
Here are the <a href="#org668e492">results</a> of the particle filter.
</p>


<div id="org668e492" class="figure">
<p><img src="./pypfilt/tau-leap-bd-posterior-estimates.png" alt="tau-leap-bd-posterior-estimates.png" width="400px" />
</p>
<p><span class="figure-number">Figure 4: </span>Forecast of birth-death process</p>
</div>
</div>
</div>
</div>

<div id="outline-container-ode-bd" class="outline-3">
<h3 id="ode-bd">ODE birth-death</h3>
<div class="outline-text-3" id="text-ode-bd">
<p>
Consider an approximation of the birth-death process using a
differential equation.
</p>
</div>

<div id="outline-container-ode-bd-process-model" class="outline-4">
<h4 id="ode-bd-process-model">Process model</h4>
<div class="outline-text-4" id="text-ode-bd-process-model">
<p>
We start by defining a model for this process which is adapted from
<a href="https://pypfilt.readthedocs.io/en/0.8.0/how-to/index.html#implement-an-ordinary-differential-equation-ode-model">this example</a>.
</p>

<div class="org-src-container">
<pre class="src src-python"># ODEBirthDeathProcess.py

&lt;&lt;imports&gt;&gt;

class ODEBirthDeathProcess(pypfilt.model.OdeModel):
    def field_types(self, ctx):
        return [('birth', np.dtype(float)),
                ('death', np.dtype(float)),
                ('x', np.dtype(float))]

    def init(self, ctx, vec):
        prior = ctx.data['prior']
        vec['x'] = prior['x']
        vec['birth'] = prior['birth']
        vec['death'] = prior['death']
        self.method = 'RK45'

    def d_dt(self, time, xt, ctx, is_forecast):
        d_dt = np.zeros(xt.shape, dtype=xt.dtype)
        d_dt['x'] = (xt['birth'] - xt['death']) * xt['x']
        return d_dt
</pre>
</div>
</div>
</div>

<div id="outline-container-org0dced55" class="outline-4">
<h4 id="org0dced55">Scenario file</h4>
<div class="outline-text-4" id="text-org0dced55">
<p>
The simulation and estimation computations are specified with a TOML
file <code>ode-bd-example.toml</code>.
</p>

<div class="org-src-container">
<pre class="src src-toml">[metadata]
name = "ODE birth-death example"
filename = "ode-bd-example.toml"
author = "Alexander E. Zarebski"
date = "2023-07-27"

[components]
model = "ODEBirthDeathProcess.ODEBirthDeathProcess"
time = "pypfilt.Scalar"
sampler = "pypfilt.sampler.LatinHypercube"
summary = "pypfilt.summary.HDF5"

[time]
start = 0.0
until = 5.0
steps_per_unit = 10
summaries_per_unit = 2

[prior]
death = { name = "constant", args.value = 1.0 }
x = { name = "constant", args.value = 1 }

[observations.x]
model = "NoisyCount.NoisyCount"
file = "ode-bd-example-x.ssv"

[filter]
particles = 10000
prng_seed = 13
history_window = -1
resample.threshold = 0.25
regularisation.enabled = true

[scenario.simulate]
prior.birth = { name = "constant", args.value = 2.0 }

[scenario.forecast]
summary.tables.model_cints.component = "pypfilt.summary.ModelCIs"
summary.tables.model_cints.credible_intervals = [ 0, 25, 50, 75, 95 ]
summary.tables.forecasts.component = "pypfilt.summary.PredictiveCIs"
summary.tables.forecasts.credible_intervals = [10, 20, 40, 80]
prior.birth = { name = "uniform", args.loc = 1.75, args.scale = 0.5 }
backcast_time = 2.0
forecast_time = 4.0

[output]
credible_intervals = "demo-ode-bd-cris.ssv"
estimate_plot = "ode-bd-posterior-estimates.png"
forecast_plot = "ode-bd-posterior-forecasts.png"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd021ee5" class="outline-4">
<h4 id="orgd021ee5">Main script</h4>
<div class="outline-text-4" id="text-orgd021ee5">
<p>
Here is the main script that runs the simulation and estimation.
</p>

<div class="org-src-container">
<pre class="src src-python"># ode-bd-example.py

&lt;&lt;imports&gt;&gt;
&lt;&lt;plotting-imports&gt;&gt;

scenario_file = 'ode-bd-example.toml'
instances = list(pypfilt.load_instances(scenario_file))
sim_instance = instances[0]
my_time_scale = sim_instance.time_scale()
my_obs_tables = pypfilt.simulate_from_model(sim_instance)

for (obs_unit, obs_table) in my_obs_tables.items():
    out_file = f'ode-bd-example-{obs_unit}.ssv'
    pypfilt.io.write_table(out_file, obs_table, my_time_scale)

</pre>
</div>

<p>
To run the forecasts on the simulated data we have the following
</p>

<div class="org-src-container">
<pre class="src src-python">fst_instance = instances[1]
backcast_time = fst_instance.settings['backcast_time']
forecast_time = fst_instance.settings['forecast_time']
context = fst_instance.build_context()
results = pypfilt.forecast(context, [forecast_time], filename=None)
</pre>
</div>

<p>
Then finally we can generate a plot showing both the future forecasted
values, but also the estiamte of the historical states of the process.
</p>

<div class="org-src-container">
<pre class="src src-python">fit = results.estimation.tables['forecasts']
forecast = results.forecasts[forecast_time].tables['forecasts']
credible_intervals = np.concatenate((
    fit[fit['time'] &gt;= backcast_time],
    forecast))

cri_df = pd.DataFrame(credible_intervals)
cri_df = cri_df.assign(prob = cri_df['prob'])
obs_df = pd.read_csv('ode-bd-example-x.ssv', sep=' ')
obs_df = obs_df[obs_df['time'] &gt;= backcast_time]
obs_df = obs_df.assign(observed = obs_df['time'] &lt;= forecast_time)

fs_p9 = (ggplot()
         + geom_ribbon(data = cri_df,
                       mapping = aes(x = "time",
                                     ymin = "ymin",
                                     ymax = "ymax",
                                     group = "prob",
                                     fill = "prob"),
                       alpha = 0.5)
         + scale_fill_gradient(low = "white", high = "black")
         + scale_x_continuous(name = "Time")
         + scale_y_continuous(name = "Population size")
         + geom_point(data = obs_df,
                      color = "red",
                      mapping = aes(x = "time",
                                    y = "value",
                                    shape = "observed"),
                      size = 3)
         + scale_shape_manual(values = {True: 'o', False: 'x'})
         + geom_vline(xintercept = forecast_time,
                      linetype = "dashed")
         + labs(title = "Population size forecast")
         + theme_bw()
         + theme(legend_position = "none"))

png_plot_fn = instances[1].settings['output']['forecast_plot']
pdf_plot_fn = png_plot_fn.replace("png", "pdf")
p9.save_as_pdf_pages([fs_p9], filename = pdf_plot_fn)
import os
os.system(f"convert -density 300 {pdf_plot_fn} {png_plot_fn}")
os.remove(pdf_plot_fn)
</pre>
</div>

<p>
Here are the <a href="#org345e12a">results</a> of the particle filter (with the code to create
the figure below).
</p>


<div id="org345e12a" class="figure">
<p><img src="./pypfilt/ode-bd-example.png" alt="ode-bd-example.png" width="400px" />
</p>
<p><span class="figure-number">Figure 5: </span>Forecast of birth-death process</p>
</div>

<p>
We can also generate a plot of how the posterior distribution
converges on the true value of the parameter as the amount of data
available increases.
</p>

<div class="org-src-container">
<pre class="src src-python">param_cris_df = pd.DataFrame(results.estimation.tables['model_cints'])
param_cris_df = param_cris_df[param_cris_df['name'] == 'birth']
param_cris_df['prob'] = pd.Categorical(
    param_cris_df['prob'],
    categories=param_cris_df['prob'].unique(),
    ordered=True
)
pt_est_mask = param_cris_df['prob'] == 0

br_ests_p9 = (ggplot()
              + geom_ribbon(data = param_cris_df,
                            mapping = aes(x = "time",
                                          ymin = "ymin",
                                          ymax = "ymax",
                                          group = "prob"),
                            alpha = 0.2,
                            size = 1)
              + geom_line(data = param_cris_df[pt_est_mask],
                          mapping = aes(x = "time",
                                        y = "ymin"))
              + geom_hline(yintercept = 2.0, linetype = "dashed")
              + scale_x_continuous(name = "Amount of data used")
              + scale_y_continuous(name = "Birth rate")
              + labs(title = "Birth rate credible intervals")
              + theme_bw())

png_plot_fn = instances[1].settings['output']['estimate_plot']
pdf_plot_fn = png_plot_fn.replace("png", "pdf")
p9.save_as_pdf_pages([br_ests_p9], filename = pdf_plot_fn)
import os
os.system(f"convert -density 300 {pdf_plot_fn} {png_plot_fn}")
os.remove(pdf_plot_fn)
</pre>
</div>

<p>
Here are the <a href="#org6748645">results</a> of the particle filter.
</p>


<div id="org6748645" class="figure">
<p><img src="./pypfilt/ode-bd-posterior-estimates.png" alt="ode-bd-posterior-estimates.png" width="400px" />
</p>
<p><span class="figure-number">Figure 6: </span>Forecast of birth-death process</p>
</div>
</div>
</div>
</div>

<div id="outline-container-ode-bd-again" class="outline-3">
<h3 id="ode-bd-again">ODE birth-death (again)</h3>
<div class="outline-text-3" id="text-ode-bd-again">
<p>
We will now use the ODE model (from <a href="#ode-bd">before</a>), but this time instead of
using the <code>forecast</code> method from <code>pypfilt</code> we will use the <code>fit</code> one.
</p>

<p>
For the process model, we will use the same one as <a href="#ode-bd-process-model">before</a>.
</p>
</div>

<div id="outline-container-org27d90bc" class="outline-4">
<h4 id="org27d90bc">Scenario file</h4>
<div class="outline-text-4" id="text-org27d90bc">
<div class="org-src-container">
<pre class="src src-toml">[metadata]
name = "ODE birth-death example (again)"
filename = "ode-bd-again-example.toml"
author = "Alexander E. Zarebski"
date = "2023-09-15"

[components]
model = "ODEBirthDeathProcess.ODEBirthDeathProcess"
time = "pypfilt.Scalar"
sampler = "pypfilt.sampler.LatinHypercube"
summary = "pypfilt.summary.HDF5"

[summary.monitors]
backcast_monitor.component = "pypfilt.summary.BackcastMonitor"
backcast_monitor.foo = "bar"

[summary.tables]
backcasts.component = "BackcastStateCIs.BackcastStateCIs"
backcasts.backcast_monitor = "backcast_monitor"
backcasts.credible_intervals = [ 0, 25, 50, 75, 95 ]

[time]
start = 0.0
until = 5.0
steps_per_unit = 10
summaries_per_unit = 2

[prior]
death = { name = "constant", args.value = 1.0 }
x = { name = "constant", args.value = 1 }
birth = { name = "uniform", args.loc = 1.75, args.scale = 0.5 }

# We will re-use the simulated data set from the last example.
[observations.x]
model = "NoisyCount.NoisyCount"
file = "ode-bd-example-x.ssv"

[filter]
particles = 10000
prng_seed = 13
history_window = -1
resample.threshold = 0.25
regularisation.enabled = true

[scenario.fit]
summary.tables.model_cints.component = "pypfilt.summary.ModelCIs"
summary.tables.model_cints.credible_intervals = [ 0, 25, 50, 75, 95 ]

[output]
estimate_plot = "ode-bd-again-posterior-birth-rate-estimates.png"
state_plot = "ode-bd-posterior-state-estimates.png"
</pre>
</div>
</div>
</div>

<div id="outline-container-org35f1795" class="outline-4">
<h4 id="org35f1795">Backcast table component</h4>
<div class="outline-text-4" id="text-org35f1795">
<p>
We need to make a small adjustment to specify the way in which the
backcast should be generated (since we are using <code>fit</code> instead of
<code>forecast</code>).
</p>

<div class="org-src-container">
<pre class="src src-python"># BackcastState.py

import pypfilt

class BackcastStateCIs(pypfilt.summary.BackcastPredictiveCIs):
    def n_rows(self, ctx, forecasting):
        n_obs_models = len(ctx.component['obs'])
        n_backcast_times = ctx.summary_count()
        return len(self._BackcastPredictiveCIs__probs) * n_backcast_times * n_obs_models
</pre>
</div>
</div>
</div>

<div id="outline-container-org5860121" class="outline-4">
<h4 id="org5860121">Main script</h4>
<div class="outline-text-4" id="text-org5860121">
<div class="org-src-container">
<pre class="src src-python"># ode-bd-again-example.py

&lt;&lt;imports&gt;&gt;
&lt;&lt;plotting-imports&gt;&gt;

scenario_file = "ode-bd-again-example.toml"

fit_inst = list(pypfilt.load_instances(scenario_file))[0]

context = fit_inst.build_context()

results = pypfilt.fit(context, filename=None)
</pre>
</div>

<p>
Using the backcasts, see the smoothed estimates of the state in the
past.
</p>

<div class="org-src-container">
<pre class="src src-python">data_df = pd.read_csv(context.settings['observations']['x']['file'],
                      sep = ' ')

bc_df = pd.DataFrame(results.estimation.tables['backcasts'])
pt_est_mask = bc_df['prob'] == 0

bc_p9 = (ggplot()
         + geom_ribbon(data = bc_df,
                       mapping = aes(x = "time",
                                     ymin = "ymin",
                                     ymax = "ymax",
                                     group = "prob"),
                       alpha = 0.2,
                       size = 1)
         + geom_line(data = bc_df[pt_est_mask],
                     mapping = aes(x = "time",
                                   y = "ymin"))
         + geom_point(data = data_df,
                      mapping = aes(x = "time", y = "value"))
         + scale_y_log10(name = "")
         + scale_x_continuous(name = "")
         + labs(title = "State credible intervals")
         + theme_bw())

bc_p9.save(context.settings['output']['state_plot'],
        height = 5.8, width = 8.3)
</pre>
</div>


<div id="org79a0e63" class="figure">
<p><img src="./pypfilt/ode-bd-posterior-state-estimates.png" alt="ode-bd-posterior-state-estimates.png" width="400px" />
</p>
</div>

<p>
Use a ribbon plot to see how the uncertainty in the parameter
estimates chnages over time.
</p>

<div class="org-src-container">
<pre class="src src-python">param_cris_df = pd.DataFrame(results.estimation.tables['model_cints'])
param_cris_df = param_cris_df[param_cris_df['name'] == 'birth']
param_cris_df['prob'] = pd.Categorical(
    param_cris_df['prob'],
    categories=param_cris_df['prob'].unique(),
    ordered=True
)
pt_est_mask = param_cris_df['prob'] == 0

br_ests_p9 = (ggplot()
              + geom_ribbon(data = param_cris_df,
                            mapping = aes(x = "time",
                                          ymin = "ymin",
                                          ymax = "ymax",
                                          group = "prob"),
                            alpha = 0.2,
                            size = 1)
              + geom_line(data = param_cris_df[pt_est_mask],
                          mapping = aes(x = "time",
                                        y = "ymin"))
              + geom_hline(yintercept = 2.0, linetype = "dashed")
              + scale_x_continuous(name = "Amount of data used")
              + scale_y_continuous(name = "Birth rate")
              + labs(title = "Birth rate credible intervals")
              + theme_bw())

br_ests_p9.save(context.settings['output']['estimate_plot'],
                height = 5.8, width = 8.3)
</pre>
</div>


<div id="orga4895b9" class="figure">
<p><img src="./pypfilt/ode-bd-again-posterior-birth-rate-estimates.png" alt="ode-bd-again-posterior-birth-rate-estimates.png" width="400px" />
</p>
</div>
</div>
</div>

<div id="outline-container-org2c14f52" class="outline-4">
<h4 id="org2c14f52">What if I want the actual trajectories?</h4>
<div class="outline-text-4" id="text-org2c14f52">
<div class="org-src-container">
<pre class="src src-python">context = fit_inst.build_context()
results = pypfilt.fit(context, filename=None)
</pre>
</div>

<p>
In order to estimate the historical state of the process we need to
resample the particles so they form a uniformly weighted sample and
then create a "backcast" using these. When resampling, we take the
last slice which correspnds to the particles at the end of the history
window.
</p>

<div class="org-src-container">
<pre class="src src-python">pypfilt.resample.resample(context,
                          results.estimation.history.matrix[-1, :])
my_backcast = results.estimation.history.create_backcast(context)
assert np.unique(my_backcast.matrix['weight']).shape == (1,)
</pre>
</div>

<p>
Reading the backcast into a data frame for plotting is complicated
by there being multiple dimensions so we reshape it first into a
suitable form.
</p>

<div class="org-src-container">
<pre class="src src-python">bc_df = np.reshape(my_backcast.matrix['state_vec'], -1)
bc_df = pd.DataFrame(bc_df)
bc_df['time'] = np.repeat(my_backcast.times, context.particle_count())
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-ctmc-bd" class="outline-3">
<h3 id="ctmc-bd">CTMC birth-death</h3>
<div class="outline-text-3" id="text-ctmc-bd">
<p>
Consider the birth-death process modelled with a CTMC.
</p>
</div>

<div id="outline-container-orgf6517b1" class="outline-4">
<h4 id="orgf6517b1">Process model</h4>
<div class="outline-text-4" id="text-orgf6517b1">
<p>
We start by defining a model for this process which is adapted from
<a href="https://pypfilt.readthedocs.io/en/0.8.0/how-to/index.html#implement-a-continuous-time-markov-chain-ctmc-model">this example</a>.
</p>

<div class="org-src-container">
<pre class="src src-python"># CTMCBirthDeathProcess.py

&lt;&lt;imports&gt;&gt;

class CTMCBirthDeathProcess(pypfilt.model.Model):
    def field_types(self, ctx):
        return [('birth', np.dtype(float)),
                ('death', np.dtype(float)),
                ('x', np.dtype(int)),
                ('next_event', np.int_),
                ('next_time', np.float_)]

    def init(self, ctx, vec):
        prior = ctx.data['prior']
        vec['x'] = prior['x']
        vec['birth'] = prior['birth']
        vec['death'] = prior['death']
        vec['next_time'] = 0
        vec['next_event'] = 0
        self.select_next_event(ctx, vec, stop_time=0)

    def update(self, ctx, time_step, is_forecast, prev, curr):
        curr[:] = prev[:]
        active = self.active_particles(curr, time_step.end)
        while any(active):
            births = np.logical_and(active, curr['next_event'] == 0)
            curr['x'][births] += 1
            deaths = np.logical_and(active, curr['next_event'] == 1)
            curr['x'][deaths] -= 1
            self.select_next_event(ctx, curr, stop_time=time_step.end)
            active = self.active_particles(curr, time_step.end)

    def active_particles(self, vec, stop_time):
        return np.logical_and(
            vec['next_time'] &lt;= stop_time,
            vec['x'] &gt; 0,
        )

    def select_next_event(self, ctx, vec, stop_time):
        active = self.active_particles(vec, stop_time)
        if not any(active):
            return

        x = vec['x'][active]
        birth = vec['birth'][active]
        death = vec['death'][active]

        birth_rate = birth * x
        death_rate = death * x
        rate_sum = birth_rate + death_rate

        rng = ctx.component['random']['model']
        dt = - np.log(rng.random(x.shape)) / rate_sum
        vec['next_time'][active] += dt

        threshold = rng.random(x.shape) * rate_sum
        death_event = threshold &gt; birth_rate
        vec['next_event'][active] = death_event.astype(np.int_)

    def can_smooth(self):
        return {'birth'}
</pre>
</div>
</div>
</div>

<div id="outline-container-org813406d" class="outline-4">
<h4 id="org813406d">Scenario file</h4>
<div class="outline-text-4" id="text-org813406d">
<p>
The simulation and estimation computations are specified with a TOML
file <code>ctmc-bd-example.toml</code>.
</p>

<div class="org-src-container">
<pre class="src src-toml">[metadata]
name = "CTMC birth-death example"
filename = "ctmc-bd-example.toml"
author = "Alexander E. Zarebski"
date = "2023-07-27"

[components]
model = "CTMCBirthDeathProcess.CTMCBirthDeathProcess"
time = "pypfilt.Scalar"
sampler = "pypfilt.sampler.LatinHypercube"
summary = "pypfilt.summary.HDF5"

[time]
start = 0.0
until = 5.0
steps_per_unit = 10
summaries_per_unit = 2

[prior]
death = { name = "constant", args.value = 1.0 }
x = { name = "constant", args.value = 1 }

[observations.x]
model = "NoisyCount.NoisyCount"
file = "ctmc-bd-example-x.ssv"

[filter]
particles = 1000
prng_seed = 1
history_window = -1
resample.threshold = 0.25
regularisation.enabled = true

[filter.regularisation.bounds]
birth = { min = 1.0, max = 3.0 }

[scenario.simulate]
prior.birth = { name = "constant", args.value = 2.0 }

[scenario.forecast]
summary.tables.model_cints.component = "pypfilt.summary.ModelCIs"
summary.tables.model_cints.credible_intervals = [ 0, 25, 50, 75, 95 ]
summary.tables.forecasts.component = "pypfilt.summary.PredictiveCIs"
summary.tables.forecasts.credible_intervals = [10, 20, 40, 80]
prior.birth = { name = "uniform", args.loc = 1.0, args.scale = 3.0 }
backcast_time = 0.0
forecast_time = 4.0

[output]
estimate_plot = "ctmc-bd-posterior-estimates.png"
forecast_plot = "ctmc-bd-posterior-forecasts.png"
</pre>
</div>
</div>
</div>

<div id="outline-container-org2fda8b2" class="outline-4">
<h4 id="org2fda8b2">Main script</h4>
<div class="outline-text-4" id="text-org2fda8b2">
<p>
Here is the main script that runs the simulation and estimation.
Because there is a substantial chance of the process going extinct, we
wrap the simulation in a loop, incrementing the seed until we find one
that gives an interesting simulation.
</p>

<div class="org-src-container">
<pre class="src src-python"># ctmc-bd-example.py

&lt;&lt;imports&gt;&gt;
&lt;&lt;plotting-imports&gt;&gt;

scenario_file = 'ctmc-bd-example.toml'
found_good_seed=False
seed = 0
while not found_good_seed:
    print("Trying seed", seed)
    instances = list(pypfilt.load_instances(scenario_file))
    sim_instance = instances[0]
    sim_instance.settings['filter']['prng_seed'] = seed
    my_time_scale = sim_instance.time_scale()
    my_obs_tables = pypfilt.simulate_from_model(sim_instance)
    found_good_seed = my_obs_tables['x']['value'][-1] &gt; 0
    seed += 1

for (obs_unit, obs_table) in my_obs_tables.items():
    out_file = f'ctmc-bd-example-{obs_unit}.ssv'
    pypfilt.io.write_table(out_file, obs_table, my_time_scale)
</pre>
</div>

<p>
To run the forecasts on the simulated data we have the following
</p>

<div class="org-src-container">
<pre class="src src-python">fst_instance = instances[1]
backcast_time = fst_instance.settings['backcast_time']
forecast_time = fst_instance.settings['forecast_time']
context = fst_instance.build_context()
results = pypfilt.forecast(context, [forecast_time], filename=None)
</pre>
</div>

<p>
Then finally we can generate a plot showing both the future forecasted
values, but also the estiamte of the historical states of the process.
</p>

<div class="org-src-container">
<pre class="src src-python">fit = results.estimation.tables['forecasts']
forecast = results.forecasts[forecast_time].tables['forecasts']
credible_intervals = np.concatenate((
    fit[fit['time'] &gt;= backcast_time],
    forecast))

cri_df = pd.DataFrame(credible_intervals)
cri_df = cri_df.assign(prob = cri_df['prob'])
obs_df = pd.read_csv('ctmc-bd-example-x.ssv', sep=' ')
obs_df = obs_df[obs_df['time'] &gt;= backcast_time]
obs_df = obs_df.assign(observed = obs_df['time'] &lt;= forecast_time)

fs_p9 = (ggplot()
         + geom_ribbon(data = cri_df,
                       mapping = aes(x = "time",
                                     ymin = "ymin",
                                     ymax = "ymax",
                                     group = "prob"),
                       alpha = 0.2)
         + scale_x_continuous(name = "Time")
         + scale_y_sqrt(name = "Population size")
         + geom_point(data = obs_df,
                      mapping = aes(x = "time",
                                    y = "value",
                                    shape = "observed"),
                      size = 3,
                      colour = "red")
         + scale_shape_manual(values = {True: 'o', False: 'x'})
         + geom_vline(xintercept = forecast_time,
                      linetype = "dashed")
         + labs(title = "Population size forecast")
         + theme_bw()
         + theme(legend_position = "none"))

fs_p9.save(instances[1].settings['output']['forecast_plot'],
           height = 4.1, width = 5.8)
</pre>
</div>

<p>
Here are the <a href="#orgc9ec825">results</a> of the particle filter (with the code to create
the figure below).
</p>


<div id="orgc9ec825" class="figure">
<p><img src="./pypfilt/ctmc-bd-posterior-forecasts.png" alt="ctmc-bd-posterior-forecasts.png" width="400px" />
</p>
<p><span class="figure-number">Figure 7: </span>Forecast of birth-death process</p>
</div>

<p>
We can also generate a plot of how the posterior distribution
converges on the true value of the parameter as the amount of data
available increases.
</p>

<div class="org-src-container">
<pre class="src src-python">param_cris_df = pd.DataFrame(results.estimation.tables['model_cints'])
param_cris_df = param_cris_df[param_cris_df['name'] == 'birth']
param_cris_df['prob'] = pd.Categorical(
    param_cris_df['prob'],
    categories=param_cris_df['prob'].unique(),
    ordered=True
)
pt_est_mask = param_cris_df['prob'] == 0

br_p9 = (ggplot()
         + geom_ribbon(data = param_cris_df,
                       mapping = aes(x = "time",
                                     ymin = "ymin",
                                     ymax = "ymax",
                                     group = "prob"),
                       alpha = 0.2,
                       size = 1)
         + geom_line(data = param_cris_df[pt_est_mask],
                     mapping = aes(x = "time",
                                   y = "ymin"))
         + geom_hline(yintercept = 2.0, linetype = "dashed", colour = "red")
         + scale_x_continuous(name = "Amount of data used")
         + scale_y_continuous(name = "Birth rate")
         + labs(title = "Birth rate credible intervals")
         + theme_bw())

br_p9.save(instances[1].settings['output']['estimate_plot'],
           height = 4.1, width = 5.8)
</pre>
</div>

<p>
Here are the <a href="#org4749a27">results</a> of the particle filter.
</p>


<div id="org4749a27" class="figure">
<p><img src="./pypfilt/ctmc-bd-posterior-estimates.png" alt="ctmc-bd-posterior-estimates.png" width="400px" />
</p>
<p><span class="figure-number">Figure 8: </span>Forecast of birth-death process</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org8d7ca8d" class="outline-2">
<h2 id="org8d7ca8d">Colophon</h2>
<div class="outline-text-2" id="text-org8d7ca8d">
<p>
Here is a requirements file for a python virtual environment to run
these examples.
</p>

<div class="org-src-container">
<pre class="src src-txt">contourpy==1.1.0
cycler==0.11.0
fonttools==4.41.1
h5py==3.9.0
kiwisolver==1.4.4
lhs==0.4.1
matplotlib==3.7.2
mizani==0.9.2
numpy==1.25.1
packaging==23.1
pandas==2.0.3
patsy==0.5.3
Pillow==10.0.0
plotnine==0.12.2
pyparsing==3.0.9
pypfilt==0.8.0
PyQt5==5.15.9
PyQt5-Qt5==5.15.2
PyQt5-sip==12.12.2
python-dateutil==2.8.2
pytz==2023.3
scipy==1.11.1
six==1.16.0
statsmodels==0.14.0
tomli==2.0.1
tomli_w==1.0.0
tzdata==2023.3
</pre>
</div>

<p>
Once you have the virtual environment set up, the examples can be run
as shown in the following example when using the \(\tau\)-leaping
code.
</p>

<pre class="example">
$ python tau-leap-bd-example.py
</pre>

<p>
Here is a source block that gets included whenever you see an imports
statement.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org9dae891">import numpy as np
import scipy.stats
import pypfilt
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="orgb05def9">import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import matplotlib as matplotlib
matplotlib.use('QtAgg')
import pandas as pd
import plotnine as p9
from plotnine import *
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Alexander E. Zarebski</p>
<p class="date">Created: 2025-01-29 Wed 13:42</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
