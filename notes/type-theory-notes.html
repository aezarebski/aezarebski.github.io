<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-04-21 Wed 13:33 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>aez-notes</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Alex Zarebski" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link id="stylesheet" rel="stylesheet" type="text/css" href="../css/stylesheet-dark.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">aez-notes</h1>
<p>
<a href="../index.html">Home</a>
</p>

<button type="button" onclick="toggleStyle()">Light/Dark</button>
<script src="./main.js"></script>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2901040">Type theory</a>
<ul>
<li><a href="#orge1a7444">Skolems constants causing trouble</a></li>
<li><a href="#orgb6b61d2">Existential types</a></li>
</ul>
</li>
<li><a href="#org5f53cf9">Functional programming</a>
<ul>
<li><a href="#orga073978">Further reading</a></li>
<li><a href="#org3dc1ec9">Functor</a></li>
<li><a href="#org78e7b3e">Applicative</a></li>
<li><a href="#orge17e399">Monad</a></li>
<li><a href="#orgd7d54eb">Foldable</a></li>
<li><a href="#orgd2e1905">Traversable</a></li>
<li><a href="#org3de53f5">Fold and friends</a></li>
<li><a href="#org5d51135">Combinators</a></li>
<li><a href="#orgcc97f60">Total and partial functions</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org2901040" class="outline-2">
<h2 id="org2901040">Type theory</h2>
<div class="outline-text-2" id="text-org2901040">
</div>
<div id="outline-container-orge1a7444" class="outline-3">
<h3 id="orge1a7444">Skolems constants causing trouble</h3>
<div class="outline-text-3" id="text-orge1a7444">
<p>
The names "skolem" and "rigid" are synonymous for Haskell. Based on this
<a href="https://stackoverflow.com/a/12722877">stackoverflow answer</a> it appears that skolem constants (types) cause a error at
compile time because they cannot be resolved. Consider the following definition
of a wrapper type
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6c3163;">{-# LANGUAGE ExistentialQuantification #-}</span>

<span style="color: #3a81c3; font-weight: bold;">data</span> <span style="color: #ba2f59; font-weight: bold;">AnyFoo</span> <span style="color: #715ab1;">=</span> forall a<span style="color: #715ab1;">.</span> <span style="color: #ba2f59; font-weight: bold;">Eq</span> a <span style="color: #715ab1;">=&gt;</span> <span style="color: #ba2f59; font-weight: bold;">AnyFoo</span> a
</pre>
</div>

<p>
If we try and define a function which unwraps,
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">getFoo</span> <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">AnyFoo</span> x<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">=</span> x
</pre>
</div>

<p>
it will not lead to a type error because it is unclear what the return type of
<code>getFoo</code> should be. However, we can still use the value in a <code>AnyFoo</code>, we just
need to avoid it appearing in the type of the function.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">boring</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">AnyFoo</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #ba2f59; font-weight: bold;">Bool</span>
<span style="color: #6c3163; font-weight: bold;">boring</span> <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">AnyFoo</span> x<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">=</span> x <span style="color: #715ab1;">==</span> x
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb6b61d2" class="outline-3">
<h3 id="orgb6b61d2">Existential types</h3>
<div class="outline-text-3" id="text-orgb6b61d2">
<p>
To make use of existential types in Haskell, you need to include the
<code>ExistentialQuantification</code> extension. Then you can implement a class such as
<code>ShowBox</code> which allows you to wrap up multiple types in a shared wrapper. The
significance of this is that it lets you write code such as the following and
have it type check.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">data</span> <span style="color: #ba2f59; font-weight: bold;">ShowBox</span> <span style="color: #715ab1;">=</span> forall s<span style="color: #715ab1;">.</span> <span style="color: #ba2f59; font-weight: bold;">Show</span> s <span style="color: #715ab1;">=&gt;</span> <span style="color: #ba2f59; font-weight: bold;">SB</span> s

<span style="color: #3a81c3; font-weight: bold;">instance</span> <span style="color: #ba2f59; font-weight: bold;">Show</span> <span style="color: #ba2f59; font-weight: bold;">ShowBox</span> <span style="color: #3a81c3; font-weight: bold;">where</span>
  show <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">SB</span> s<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">=</span> show s 

<span style="color: #6c3163; font-weight: bold;">heteroList</span> <span style="color: #715ab1;">::</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">ShowBox</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">heteroList</span> <span style="color: #715ab1;">=</span> <span style="color: #3a81c3;">[</span><span style="color: #ba2f59; font-weight: bold;">SB</span> <span style="color: #6c3163; font-weight: bold;">()</span>, <span style="color: #ba2f59; font-weight: bold;">SB</span> <span style="color: #4e3163;">5</span>, <span style="color: #ba2f59; font-weight: bold;">SB</span> <span style="color: #ba2f59; font-weight: bold;">True</span><span style="color: #3a81c3;">]</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5f53cf9" class="outline-2">
<h2 id="org5f53cf9">Functional programming</h2>
<div class="outline-text-2" id="text-org5f53cf9">
</div>
<div id="outline-container-orga073978" class="outline-3">
<h3 id="orga073978">Further reading</h3>
<div class="outline-text-3" id="text-orga073978">
</div>
<div id="outline-container-org7cf6f61" class="outline-4">
<h4 id="org7cf6f61">Blog posts</h4>
<div class="outline-text-4" id="text-org7cf6f61">
<ul class="org-ul">
<li><a href="https://kowainik.github.io/posts/totality">Discussion of totality of functions</a> **</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3dc1ec9" class="outline-3">
<h3 id="org3dc1ec9">Functor</h3>
<div class="outline-text-3" id="text-org3dc1ec9">
<p>
<code>&lt;$&gt;</code> is infix for <code>fmap</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">Functor</span> f <span style="color: #3a81c3; font-weight: bold;">where</span>
  fmap <span style="color: #715ab1;">::</span> <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> b<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> f a <span style="color: #715ab1;">-&gt;</span> f b
</pre>
</div>

<p>
The functor laws are <code>fmap id = id</code> and <code>fmap (f . g) == fmap f . fmap g</code>. The
intuition behind this type class is that it should act as a container and the
<code>fmap</code> should not disrupt the structure in the container.
</p>
</div>
</div>

<div id="outline-container-org78e7b3e" class="outline-3">
<h3 id="org78e7b3e">Applicative</h3>
<div class="outline-text-3" id="text-org78e7b3e">
<p>
<code>&lt;*&gt;</code> is infix the "apply" function when working with applicatives.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">Functor</span> f <span style="color: #715ab1;">=&gt;</span> <span style="color: #ba2f59; font-weight: bold;">Applicative</span> f <span style="color: #3a81c3; font-weight: bold;">where</span>
  pure  <span style="color: #715ab1;">::</span> a <span style="color: #715ab1;">-&gt;</span> f a
  <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">&lt;*&gt;</span><span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">::</span> f <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> b<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> f a <span style="color: #715ab1;">-&gt;</span> f b
</pre>
</div>

<p>
This is like a stronger version of functor where the function being applied can
also live in the <i>computational context</i> of the container.
</p>
</div>
</div>

<div id="outline-container-orge17e399" class="outline-3">
<h3 id="orge17e399">Monad</h3>
<div class="outline-text-3" id="text-orge17e399">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">Applicative</span> m <span style="color: #715ab1;">=&gt;</span> <span style="color: #ba2f59; font-weight: bold;">Monad</span> m <span style="color: #3a81c3; font-weight: bold;">where</span>
  <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">&gt;&gt;=</span><span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">::</span> m a <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> m b<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> m b
  return <span style="color: #715ab1;">::</span> a <span style="color: #715ab1;">-&gt;</span> m a 
  <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">&gt;&gt;</span><span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">::</span> m a <span style="color: #715ab1;">-&gt;</span> m b <span style="color: #715ab1;">-&gt;</span> m b 

<span style="color: #6c3163; font-weight: bold;">join</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Monad</span> m <span style="color: #715ab1;">=&gt;</span> m <span style="color: #3a81c3;">(</span>m a<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> m a 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7d54eb" class="outline-3">
<h3 id="orgd7d54eb">Foldable</h3>
<div class="outline-text-3" id="text-orgd7d54eb">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">Foldable</span> t <span style="color: #3a81c3; font-weight: bold;">where</span>
  foldMap <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Monoid</span> m <span style="color: #715ab1;">=&gt;</span> <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> m<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> t a <span style="color: #715ab1;">-&gt;</span> m
  foldr   <span style="color: #715ab1;">::</span> <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> b <span style="color: #715ab1;">-&gt;</span> b<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> b <span style="color: #715ab1;">-&gt;</span> t a <span style="color: #715ab1;">-&gt;</span> b
</pre>
</div>

<p>
The intuition behind this type class is that it should act as a container that
can be collapsed down to a single value.
</p>
</div>
</div>

<div id="outline-container-orgd2e1905" class="outline-3">
<h3 id="orgd2e1905">Traversable</h3>
<div class="outline-text-3" id="text-orgd2e1905">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">Functor</span> t, <span style="color: #ba2f59; font-weight: bold;">Foldable</span> t<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">=&gt;</span> <span style="color: #ba2f59; font-weight: bold;">Traversable</span> t <span style="color: #3a81c3; font-weight: bold;">where</span>
  traverse  <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Applicative</span> f <span style="color: #715ab1;">=&gt;</span> <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> f b<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> t a <span style="color: #715ab1;">-&gt;</span> f <span style="color: #3a81c3;">(</span>t b<span style="color: #3a81c3;">)</span>
  sequenceA <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Applicative</span> f <span style="color: #715ab1;">=&gt;</span> t <span style="color: #3a81c3;">(</span>f a<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> f <span style="color: #3a81c3;">(</span>t a<span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
This is a bit like a functor where the function returns values in a context.
</p>
</div>
</div>

<div id="outline-container-org3de53f5" class="outline-3">
<h3 id="org3de53f5">Fold and friends</h3>
<div class="outline-text-3" id="text-org3de53f5">
<p>
The friends include: scan, accumulate, and reduce.
</p>
</div>

<div id="outline-container-org2450a05" class="outline-4">
<h4 id="org2450a05">Left fold</h4>
<div class="outline-text-4" id="text-org2450a05">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">foldl</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Foldable</span> t <span style="color: #715ab1;">=&gt;</span> <span style="color: #3a81c3;">(</span>b <span style="color: #715ab1;">-&gt;</span> a <span style="color: #715ab1;">-&gt;</span> b<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> b <span style="color: #715ab1;">-&gt;</span> t a <span style="color: #715ab1;">-&gt;</span> b 

<span style="color: #6c3163; font-weight: bold;">foldl</span> f z <span style="color: #3a81c3;">[</span>x1, x2, <span style="color: #715ab1;">...</span>, xn<span style="color: #3a81c3;">]</span> <span style="color: #715ab1;">==</span> <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">...</span><span style="color: #6c3163;">(</span><span style="color: #2d9574;">(</span>z <span style="color: #715ab1;">`f`</span> x1<span style="color: #2d9574;">)</span> <span style="color: #715ab1;">`f`</span> x2<span style="color: #6c3163;">)</span> <span style="color: #715ab1;">`f`...</span><span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">`f`</span> xn
</pre>
</div>

<p>
This will build a collections of thunks, to it is probably better to use the
strict version <code>foldl'</code>.
</p>
</div>
</div>

<div id="outline-container-orgc0d6b60" class="outline-4">
<h4 id="orgc0d6b60">Right fold</h4>
<div class="outline-text-4" id="text-orgc0d6b60">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6c3163; font-weight: bold;">foldr</span> <span style="color: #715ab1;">::</span> <span style="color: #ba2f59; font-weight: bold;">Foldable</span> t <span style="color: #715ab1;">=&gt;</span> <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> b <span style="color: #715ab1;">-&gt;</span> b<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> b <span style="color: #715ab1;">-&gt;</span> t a <span style="color: #715ab1;">-&gt;</span> b

<span style="color: #6c3163; font-weight: bold;">foldr</span> f z <span style="color: #3a81c3;">[</span>x1, x2, <span style="color: #715ab1;">...</span>, xn<span style="color: #3a81c3;">]</span> <span style="color: #715ab1;">==</span> x1 <span style="color: #715ab1;">`f`</span> <span style="color: #3a81c3;">(</span>x2 <span style="color: #715ab1;">`f`</span> <span style="color: #715ab1;">...</span> <span style="color: #6c3163;">(</span>xn <span style="color: #715ab1;">`f`</span> z<span style="color: #6c3163;">)</span><span style="color: #715ab1;">...</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
This one can be applied to infinte lists and still terminate.
</p>
</div>
</div>
</div>

<div id="outline-container-org5d51135" class="outline-3">
<h3 id="org5d51135">Combinators</h3>
<div class="outline-text-3" id="text-org5d51135">
</div>
<div id="outline-container-org5adc024" class="outline-4">
<h4 id="org5adc024">on</h4>
<div class="outline-text-4" id="text-org5adc024">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #da8b55;">-- | @'on' b u x y@ runs the binary function @b@ </span><span style="color: #da8b55; font-style: italic;">/on/</span><span style="color: #da8b55;"> the results of applying</span>
<span style="color: #da8b55;">-- unary function @u@ to two arguments @x@ and @y@. From the opposite</span>
<span style="color: #da8b55;">-- perspective, it transforms two inputs and combines the outputs.</span>
<span style="color: #6c3163; font-weight: bold;">on</span> <span style="color: #715ab1;">::</span> <span style="color: #3a81c3;">(</span>b <span style="color: #715ab1;">-&gt;</span> b <span style="color: #715ab1;">-&gt;</span> c<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> b<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> a <span style="color: #715ab1;">-&gt;</span> a <span style="color: #715ab1;">-&gt;</span> c
</pre>
</div>
</div>
</div>

<div id="outline-container-org568eb9e" class="outline-4">
<h4 id="org568eb9e">&amp;</h4>
<div class="outline-text-4" id="text-org568eb9e">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #da8b55;">-- | '&amp;' is a reverse application operator.  This provides notational</span>
<span style="color: #da8b55;">-- convenience.  Its precedence is one higher than that of the forward</span>
<span style="color: #da8b55;">-- application operator '$', which allows '&amp;' to be nested in '$'.</span>
<span style="color: #da8b55;">--</span>
<span style="color: #da8b55;">-- &gt;&gt;&gt; 5 &amp; (+1) &amp; show</span>
<span style="color: #da8b55;">-- "6"</span>
<span style="color: #3a81c3;">(</span><span style="color: #6c3163; font-weight: bold;">&amp;</span><span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">::</span> a <span style="color: #715ab1;">-&gt;</span> <span style="color: #3a81c3;">(</span>a <span style="color: #715ab1;">-&gt;</span> b<span style="color: #3a81c3;">)</span> <span style="color: #715ab1;">-&gt;</span> b
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcc97f60" class="outline-3">
<h3 id="orgcc97f60">Total and partial functions</h3>
<div class="outline-text-3" id="text-orgcc97f60">
<p>
A partial function is a generalisation of a mathematical function which allows
the function to be defined on only a subset of the domain. If a function is not
partial it is pure. 
</p>

<p>
When programming, partial functions can lead to hard to bugs. Use the of maybe
monad or the either monad can be useful to avoid partial functions. Pattern
matching as case switches can be a source of partial functions but there are
static analysis tools to help with this for strong languages.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Alex Zarebski</p>
<p class="date">Created: 2021-04-21 Wed 13:33</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
